package com.wangert.vhw.utils;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Base64;

import javax.crypto.Cipher;
import java.security.*;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

public class ECCUtil {

    static {

        Security.addProvider(new BouncyCastleProvider());

    }

    //生成密钥对
    public static KeyPair getKeyPair() throws Exception {

        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("EC");

        keyPairGenerator.initialize(256, new SecureRandom());

        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        return keyPair;

    }

    //获取base64编码的公钥
    public static byte[] getPublicKey(KeyPair keyPair) {

        ECPublicKey publicKey = (ECPublicKey)keyPair.getPublic();

        byte[] bytes = publicKey.getEncoded();

        return Base64.encode(bytes);

    }

    //获取base64编码的私钥
    public static byte[] getPrivateKey(KeyPair keyPair) {

        ECPrivateKey privateKey = (ECPrivateKey)keyPair.getPrivate();

        byte[] bytes = privateKey.getEncoded();

        return Base64.encode(bytes);

    }

    //将base64编码后的公钥转换成PublicKey对象
    public static ECPublicKey stringToPublicKey(byte[] base64Public) throws Exception {

        byte[] keyBytes = Base64.decode(base64Public);
        //byte[] keyBytes = publicStr;

        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);

        KeyFactory keyFactory = KeyFactory.getInstance("EC");

        ECPublicKey publicKey = (ECPublicKey)keyFactory.generatePublic(keySpec);

        return publicKey;

    }

    //将base64编码后的私钥转换成PrivateKey对象
    public static ECPrivateKey stringToPrivateKey(byte[] base64Private) throws Exception {

        byte[] keyBytes = Base64.decode(base64Private);
        //byte[] keyBytes = privateStr;

        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);

        KeyFactory keyFactory = KeyFactory.getInstance("EC");

        ECPrivateKey privateKey = (ECPrivateKey)keyFactory.generatePrivate(keySpec);

        return privateKey;

    }

    //公钥加密
    public static byte[] publicEncrypt(byte[] content, PublicKey publicKey) throws Exception {

        Cipher cipher = Cipher.getInstance("ECIES");

        cipher.init(Cipher.ENCRYPT_MODE, publicKey);

        byte[] bytes = cipher.doFinal(content);

        return bytes;

    }

    //私钥解密
    public static byte[] privateDecrypt(byte[] cipherContent, PrivateKey privateKey) throws Exception {

        Cipher cipher = Cipher.getInstance("ECIES");

        cipher.init(Cipher.DECRYPT_MODE, privateKey);

        byte[] bytes = cipher.doFinal(cipherContent);

        return bytes;

    }

    //进行签名
    public static byte[] privateSignature(byte[] identity, PrivateKey privateKey) throws Exception {

        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());

        KeyFactory keyFactory = KeyFactory.getInstance("EC");

        privateKey = keyFactory.generatePrivate(pkcs8EncodedKeySpec);

        Signature signature = Signature.getInstance("SHA256withECDSA");

        signature.initSign(privateKey);

        signature.update(identity);

        byte[] result = signature.sign();

        return result;

    }

    //验证签名
    public static boolean publicVerifySignature(byte[] result, byte[] identity, PublicKey publicKey) throws Exception {

        X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKey.getEncoded());

        KeyFactory keyFactory = KeyFactory.getInstance("EC");

        publicKey = keyFactory.generatePublic(x509EncodedKeySpec);

        Signature signature = Signature.getInstance("SHA256withECDSA");

        signature.initVerify(publicKey);

        signature.update(identity);

        return signature.verify(result);

    }



    /*

    public static void main(String[] args) throws Exception {

        ECCUtil ecc1 = new ECCUtil();

        PropertyUtil propertyUtil = new PropertyUtil("/Users/joten/Java/vhw/src/main/resources/config/keyPair.properties");

        PublicKey publicKey = ecc1.stringToPublicKey(propertyUtil.getData("vhwAddressPublicKey").getBytes());
        PrivateKey privateKey = ecc1.stringToPrivateKey(propertyUtil.getData("vhwAddressPrivateKey").getBytes());

        //KeyPair keyPair = ecc1.getKeyPair();

        //PublicKey publicKey = ecc1.stringToPublicKey(ecc1.getPublicKey(keyPair));
        //PrivateKey privateKey = ecc1.stringToPrivateKey(ecc1.getPrivateKey(keyPair));


        byte[] content = "wangjitaoTest".getBytes();

        byte[] cipher = ecc1.publicEncrypt(content, publicKey);



        byte[] base64Cipher = Base64.encode(cipher);

        System.out.println("cipher length: " + base64Cipher.length);
        //System.out.println("base length:" + (cipher.length - "wangjitao".getBytes().length));

        String s = new String(base64Cipher);

        System.out.println(base64Cipher.toString());

        content = ecc1.privateDecrypt(Base64.decode(s.getBytes()), privateKey);

        System.out.println(new String(content));



        ParseUtil parseUtil = new ParseUtil();

        byte[] result = ecc1.privateSignature("wjt".getBytes(), privateKey);

        byte[] base64Result = Base64.encode(result);

        System.out.println("signature length: " + base64Result.length);
        System.out.println(Hex.encode(base64Result));
        System.out.println(Hex.encode(new String(base64Result).getBytes()));

        System.out.println(ecc1.publicVerifySignature(Base64.decode(base64Result), "wjt".getBytes(), publicKey));


        byte[] message = parseUtil.byteMerger(base64Cipher, base64Result);
        System.out.println("message length: " + message.length);
        System.out.println(Hex.encode(message));

        byte[] cipherTest = parseUtil.subByte(message, 0, 128);

        System.out.println(cipherTest.length);
        System.out.println(new String(cipherTest));

    }
    */

}
