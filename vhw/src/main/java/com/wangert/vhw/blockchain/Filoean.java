package com.wangert.vhw.blockchain;

import cn.filoop.sdk.client.SDKClient;
import cn.hyperchain.sdk.account.Account;
import cn.hyperchain.sdk.common.solidity.Abi;
import cn.hyperchain.sdk.common.utils.ByteUtil;
import cn.hyperchain.sdk.common.utils.FileUtil;
import cn.hyperchain.sdk.common.utils.FuncParams;
import cn.hyperchain.sdk.response.CompileResponse;
import cn.hyperchain.sdk.response.ReceiptResponse;
import cn.hyperchain.sdk.service.AccountService;
import cn.hyperchain.sdk.service.ServiceManager;
import cn.hyperchain.sdk.transaction.Transaction;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 *
 * 飞洛区块链类，封装调用方法
 * @Author：Wangert
 *
 */

public class Filoean {

    //SDKClient变量
    SDKClient sdkClient;
    //合约abi
    Abi abi;
    //合约bin
    String bin;
    //合约地址
    String contractAddress;
    //是否测试链
    boolean test;

    //构造函数(参数：AppKey，AppSecret，合约UUID，是否使用测试链)
    public Filoean(String appKey, String appSecret, String uuid, boolean test, String contractAddress) {

        System.out.println("====================SDK初始化====================");

        //创建SDKClient实例
        sdkClient = new SDKClient();
        //设置SDK初始化参数
        sdkClient.setAppKey(appKey);
        sdkClient.setAppSecret(appSecret);
        sdkClient.setUuid(uuid);

        //判断是否使用测试链
        if (test == true) {
            this.test = true;
            sdkClient.setFiloceanTest(true);
        } else {
            this.contractAddress = contractAddress;
        }

        test = false;

        //初始化SDK，获得鉴权token和操作区块链的证书文件
        sdkClient.init();

    }

    //测试链编译合约
    public void complieContract(String contractPath) throws IOException {

        //判断是否是测试状态
        if (test == false) {
            System.out.println("只允许测试链使用该函数！！！");
            System.exit(1);
        }

        System.out.println("====================合约编译====================");

        //将源码转为字符串
        String sourceCode = FileUtil.readFile(Thread.currentThread().getContextClassLoader().getResourceAsStream(contractPath));
        //编译合约，获得编译结果
        CompileResponse compileResponse = sdkClient.Complie(sourceCode);
        //设置合约bin
        bin = compileResponse.getBin()[0];
        //设置合约abi
        String abiStr = compileResponse.getAbi()[0];
        abi = Abi.fromJson(abiStr);

        System.out.println("Abi:\n" + abiStr);
        System.out.println("Bin:\n" + bin);

    }

    //测试链部署无构造函数合约
    public void deployNoContractToTestChain(String accountPrivateJson) {

        //判断是否是测试状态
        if (test == false) {
            System.out.println("只允许测试链使用该函数！！！");
            System.exit(1);
        }

        System.out.println("====================合约部署====================\"");

        //创建交易发起账号地址
        AccountService accountService = ServiceManager.getAccountService(sdkClient.getProviderManager());
        Account account = accountService.fromAccountJson(accountPrivateJson, "");
        System.out.println("账户Json： "+account.toJson());

        //创建合约发布交易
        Transaction transaction = new Transaction.EVMBuilder(account.getAddress()).deploy(bin).build();
        //交易签名
        transaction.sign(account);
        //通过sdkClient部署合约
        ReceiptResponse receiptResponse = sdkClient.deploy(transaction);
        contractAddress = receiptResponse.getContractAddress();

        System.out.println("FiloeanContract Address: " + contractAddress);
        System.out.println("账户私钥: " + account.getPrivateKey());

    }

    //测试链部署有构造函数合约
    public void deployContractToTestChain(String accountPrivateJson, FuncParams params) {

        //判断是否是测试状态
        if (test == false) {
            System.out.println("只允许测试链使用该函数！！！");
            System.exit(1);
        }

        System.out.println("====================合约部署====================");

        //创建交易发起账号地址
        AccountService accountService = ServiceManager.getAccountService(sdkClient.getProviderManager());
        Account account = accountService.fromAccountJson(accountPrivateJson, "");
        System.out.println("账户Json： "+account.toJson());

        //创建合约发布交易
        Transaction transaction = new Transaction.EVMBuilder(account.getAddress()).deploy(bin, abi, params).build();
        //交易签名
        transaction.sign(account);
        //通过sdkClient部署合约
        ReceiptResponse receiptResponse = sdkClient.deploy(transaction);
        contractAddress = receiptResponse.getContractAddress();

        System.out.println("FiloeanContract Address: " + contractAddress);
        System.out.println("账户私钥: " + account.getPrivateKey());

    }

    //公链加载合约bin和abi
    public void loadBinAndAbi(String contractBinPath, String contractAbiPath) throws IOException {

        System.out.println("====================加载合约====================");

        InputStream inputStreamBin = Thread.currentThread().getContextClassLoader().getResourceAsStream(contractBinPath);
        bin = FileUtil.readFile(inputStreamBin);

        InputStream inputStreamAbi = Thread.currentThread().getContextClassLoader().getResourceAsStream(contractAbiPath);
        String abiStr = FileUtil.readFile(inputStreamAbi);
        abi = Abi.fromJson(abiStr);


    }

    //合约调用
    public List<?> invokeContract(String accountPrivateJson, String functionName, FuncParams params) {

        System.out.println("====================合约调用====================");

        //创建交易发起账号地址
        AccountService accountService = ServiceManager.getAccountService(sdkClient.getProviderManager());
        Account account = accountService.fromAccountJson(accountPrivateJson, "");
        System.out.println("账户Json： "+account.toJson());

        //创建合约调用交易
        Transaction transaction = new Transaction.EVMBuilder(account.getAddress()).invoke(contractAddress, functionName, abi, params).build();
        //交易签名
        transaction.sign(account);

        //通过sdkClient调用合约
        ReceiptResponse receiptResponse = sdkClient.invoke(transaction);
        System.out.println("合约调用Receipt：\n" + receiptResponse);

        System.out.println("====================合约返回值解码====================");
        byte[] bytes = ByteUtil.fromHex(receiptResponse.getRet());
        List<?> objects = abi.getFunction(functionName).decodeResult(bytes);

        return objects;

    }

}
