package com.wangert.vhw.service;

import com.wangert.vhw.contracts.UserStorageContract;
import com.wangert.vhw.contracts.VulnerabilityStorageContract;
import com.wangert.vhw.dao.IpfsStorage;
import com.wangert.vhw.utils.FileUtil;
import com.wangert.vhw.utils.PropertyUtil;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 *
 * 漏洞相关服务类
 * @Author：Wangert
 *
 */

public class VulnerabilityService {
    //存储漏洞文件的文件夹
    final String vulnerabilityPath = "src/main/resources/files/vulnerabilities/";
    //存储下载后的文件
    final String ipfsDownloadPath = "src/main/resources/files/ipfsDownload/";
    //记录所有已经发布的漏洞Hash
    final String vulnerabilityListPath = "src/main/resources/dataCache/vulnerabilityList.txt";
    //主页数据缓存路径
    final String homePageDataPath = "src/main/resources/dataCache/homePageData.properties";
    //记录每个用户所发布的漏洞缓存文件的前缀
    final String userVulnerabilitiesPrefix = "src/main/resources/dataCache/userVulnerabilities/";
    //记录评估行为
    final String vulnerabilityAssessmentPath = "src/main/resources/dataCache/dashboardData/vulnerabilityAssessment.txt";

    public VulnerabilityService() {}

    //上传漏洞到IPFS并且将Hash记录到区块链
    public boolean publishVulnerability(String username, String vulnerabilityName, String description, String vulnerabilityStorageName) {


        //声明IPFS文件存储工具对象
        IpfsStorage ipfsStorage = new IpfsStorage();
        //声明漏洞合约类
        VulnerabilityStorageContract vulnerabilityStorageContract = new VulnerabilityStorageContract();
        //声明用户合约类
        UserStorageContract userStorageContract = new UserStorageContract();
        //记录返回ipfsHash
        String ipfsHash;

        //判断用户是否存在
        if (!userStorageContract.userExisted(username)) {

            System.out.println(username + "not exist！");

            return false;

        }

        try {
            //将对应文件上传至ipfs
            ipfsHash = ipfsStorage.ipfsUpload(vulnerabilityPath + vulnerabilityStorageName);
            System.out.println("ipfsHash:" + ipfsHash);

            Date date = new Date();
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String currentDate = dateFormat.format(date);
            //调用合约添加漏洞
            boolean addFlag = vulnerabilityStorageContract.addVulnerability(ipfsHash, vulnerabilityName, username, currentDate);

            //添加失败
            if (addFlag == false) {

                System.out.println("Vulnerability add failed!");
                return false;

            }

            //修改用户数据信息
            addFlag = userStorageContract.addReleaseVulnerability(username, ipfsHash);
            if (addFlag == false) {

                System.out.println("Update user information failed!");
                return false;

            }

            //文件操作工具对象
            FileUtil fileUtil = new FileUtil();
            //将新漏洞Hash写入到缓存文件中
            fileUtil.fileWrite(ipfsHash, vulnerabilityListPath);
            fileUtil.fileWrite(ipfsHash, userVulnerabilitiesPrefix + username + ".txt");

            //主页数据缓存文件操作对象
            PropertyUtil propertyUtil = new PropertyUtil(homePageDataPath);

            //漏洞名称@@@发布者@@@发布时间@@@修复时间@@@漏洞描述@@@漏洞star数@@@漏洞评分@@@评估人数
            String newData = vulnerabilityName + "@@@" + username + "@@@" + currentDate + "@@@" + "not fix" + "@@@" + description + "@@@0@@@0@@@0";
            //写入到主页数据缓存文件中
            propertyUtil.appendData(ipfsHash, newData, ipfsHash + "=漏洞名称@@@发布者@@@发布时间@@@修复时间@@@漏洞描述@@@漏洞star数@@@漏洞评分@@@评估人数");


        }catch (Exception e) {
            e.printStackTrace();
        }


        return true;

    }

    //根据ipfsHash下载漏洞
    public void downloadVulnerabilityByIpfsHash(String ipfsHash) {
        //声明IPFS文件存储工具对象
        IpfsStorage ipfsStorage = new IpfsStorage();

        try {

            //从ipfs上下载漏洞
            ipfsStorage.ipfsDownloadByHash(ipfsDownloadPath + ipfsHash + ".zip", ipfsHash);

        }catch (IOException e) {
            e.printStackTrace();
        }

    }

    //评估漏洞
    public boolean assessVulnerabilityByIpfsHash(String assessor, String ipfsHash, int score) {
        //定义用户合约操作对象
        UserStorageContract userStorageContract = new UserStorageContract();
        //定义漏洞合约操作对象
        VulnerabilityStorageContract vulnerabilityStorageContract = new VulnerabilityStorageContract();
        //更新后的总评分
        int newScore;

        Date date = new Date();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String currentDate = dateFormat.format(date);

        //缓存文件数据操作对象
        PropertyUtil propertyUtil = new PropertyUtil(homePageDataPath);
        try {

            //从缓存文件中获取数据
            //漏洞名称@@@发布者@@@发布时间@@@修复时间@@@漏洞描述@@@漏洞star数@@@漏洞评分@@@评估人数
            String s = propertyUtil.getData(ipfsHash);
            String c = propertyUtil.getData(assessor + "Contribution");
            String[] arrStr = s.split("@@@");
            int oldScore = Integer.valueOf(arrStr[6]).intValue();
            int oldNumberOfUser = Integer.valueOf(arrStr[7]).intValue();

            //记录该assessor评估此漏洞
            if (userStorageContract.addAssessVulnerabilitiesScore(assessor, ipfsHash, score) == false) {
                System.out.println(assessor+"已经评估过" + ipfsHash);
                return false;
            }
            //修改assessor的贡献值
            userStorageContract.addTotalAndResidualContribution(assessor, 5);
            //更新用户贡献值
            String[] cArrStr =  c.split("@@@");
            int newRContribution = Integer.valueOf(cArrStr[0]).intValue() + 5;
            int newTContribution = Integer.valueOf(cArrStr[1]).intValue() + 5;
            String newContribution = newRContribution + "@@@" + newTContribution;

            int oldTContribution = Integer.valueOf(cArrStr[1]);

            //计算评估后的新总分
            //加权后评分
            newScore = (int)(oldScore * oldNumberOfUser + score * ((float)(oldTContribution + 5)/(55 + oldTContribution)) * 2) / (oldNumberOfUser + 1);

            System.out.println("newScore:" + newScore);
            //此处合约有误
            vulnerabilityStorageContract.addVulnerabilityTotalScore(ipfsHash, newScore);

            //漏洞名称@@@发布者@@@发布时间@@@修复时间@@@漏洞描述@@@漏洞star数@@@漏洞评分@@@评估人数
            //新评估人数
            int newNumberOfUser = oldNumberOfUser + 1;
            String newVulnerabilityData = arrStr[0] + "@@@" + arrStr[1] + "@@@" + arrStr[2] + "@@@" + arrStr[3] + "@@@" + arrStr[4] + "@@@" + arrStr[5] + "@@@" + newScore + "@@@" + newNumberOfUser;

            propertyUtil.updateData(assessor + "Contribution", newContribution, "update");
            propertyUtil.updateData(ipfsHash, newVulnerabilityData, "update");

            FileUtil fileUtil = new FileUtil();
            String assessRecord = currentDate + "@@@" + assessor + "@@@" + ipfsHash + "@@@" + score;
            fileUtil.fileWrite(assessRecord, vulnerabilityAssessmentPath);


        }catch (Exception e) {
            e.printStackTrace();
        }




        return true;
    }


    //增加漏洞star
    public boolean addStar(String ipfsHash) {

        //声明漏洞合约对象
        VulnerabilityStorageContract vulnerabilityStorageContract = new VulnerabilityStorageContract();
        //漏洞star加一
        boolean addFlag = vulnerabilityStorageContract.incStar(ipfsHash);
        //判断star是否记录
        if (addFlag == false) {
            System.out.println("Add Vulnerability star falided!");
            return false;
        }

        return true;

    }

    /*
    public static void main(String[] args) {
       VulnerabilityService vulnerabilityService = new VulnerabilityService();

       vulnerabilityService.downloadVulnerabilityByIpfsHash("QmTuSjAM7wdpAmWDrTABWgguwUfCXPfmYnRLvDiTCBj5w9");

    }
    */


}
