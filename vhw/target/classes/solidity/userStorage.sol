pragma solidity ^0.4.10;

contract UserStorage {
    
    //用户结构体
    struct User {
        //用户名
        string username;
        //vhw地址
        string vhwAddress;
        //加密后的密码
        string encryptedPassword;
        //总贡献值
        uint64 totalContribution;
        //剩余贡献值
        uint64 residualContribution;
        //发布的漏洞列表
        string[] vulnerabilities;
        //发布的漏洞数量
        uint64 vCount;
        //发布的补丁列表
        string[] patches;
        //发布的补丁数量
        uint64 pCount;
        //漏洞打分情况
        mapping(string => uint8) vulnerabilitiesScore;
        //补丁打分情况
        mapping(string => uint8) patchesScore;
        //判断用户是否存在
        bool isExisted;
        
    }    
    
    //用户列表
    mapping(string => User) userMap;
    
    
    //判断用户是否存在
    function userExisted(string username) public returns (bool) {
        
        if (userMap[username].isExisted) {
            return true;
        }
       
        return false;
    }
    
    //用户登录验证
    function verifyUser(string username, string vhwAddress, string encryptedPassword) public returns (bool) {
        //计算参数的keccak256哈希
        bytes32 currentUsernameHash = keccak256(username);
        bytes32 currentVhwAddressHash = keccak256(vhwAddress);
        bytes32 currentPasswordHash = keccak256(encryptedPassword);
        
        //计算原来用户名和密码的keccak256哈希
        bytes32 blockchainUsernameHash = keccak256(userMap[username].username);
        bytes32 blockchainVhwAddressHash = keccak256(userMap[username].vhwAddress);
        bytes32 blockchainPasswordHash = keccak256(userMap[username].encryptedPassword);
        
        
        //验证三者是否一致
        if (currentUsernameHash == blockchainUsernameHash && currentVhwAddressHash == blockchainVhwAddressHash && currentPasswordHash == blockchainPasswordHash) {
        
            return true;
        }
            
        return false;
    }
    
    //新增用户
    function addUser(string username, string vhwAddress, string encryptedPassword) public returns (bool) {
        
        //判断用户是否存在
        if (userExisted(username)) {
            return false;
        }
        
        //新建用户实例
        userMap[username].username = username;
        userMap[username].vhwAddress = vhwAddress;
        userMap[username].encryptedPassword = encryptedPassword;
        userMap[username].totalContribution = 0;
        userMap[username].residualContribution = 0;
        userMap[username].isExisted = true;
        userMap[username].vCount = 0;
        userMap[username].pCount = 0;
        
        return true;
    }
    
    //增加发布的漏洞
    function addReleaseVulnerability(string username, string vulnerabilityIpfsHash) public returns (bool) {
        
        if (userExisted(username)) {
            
            //添加新发布的漏洞ipfs哈希
            userMap[username].vulnerabilities.push(vulnerabilityIpfsHash);
            userMap[username].vCount++;
            
            return true;
            
        }
        
        return false;
        
    }
    
    //增加发布的补丁
    function addReleasePatch(string username, string patchIpfsHash) public returns (bool) {
        
        if (userExisted(username)) {
            
            //添加新发布的补丁ipfs哈希
            userMap[username].patches.push(patchIpfsHash);
            userMap[username].pCount++;
            
            return true;
        }
        
        return false;
    }
    
    //增加漏洞打分情况
    function addAssessVulnerabilitiesScore(string username, string assessor, uint8 score) public returns (bool) {
        //判断用户是否存在
        if (userExisted(username)) {
            //判断该用户是否已经评价过该漏洞
            if (userMap[username].vulnerabilitiesScore[assessor] == 0) {
                userMap[username].vulnerabilitiesScore[assessor] = score;
                
                return true;
            }
        }
        
        return false;
        
    }
    
    //增加补丁打分情况
    function addAssessPatchScore(string username, string assessor, uint8 score) public returns (bool) {
        //判断用户是否存在
        if (userExisted(username)) {
            //判断该用户是否已经评价过该漏洞
            if (userMap[username].patchesScore[assessor] == 0) {
                userMap[username].patchesScore[assessor] = score;
                
                return true;
            }
        }
        
        return false;
        
    }
    
    //增加总贡献值
    function addTotalAndResidualContribution(string username, uint64 contribution) public returns (bool) {
        
        //判断用户是否存在,存在才增加贡献值
        if (userExisted(username)) {
            
            //增加总贡献值
            userMap[username].totalContribution += contribution;
            userMap[username].residualContribution += contribution;
            
            return true;
        }
        
        //由于用户不存在，贡献值增加失败
        return false;
    }
    
    //消耗剩余贡献值
    function useResidualContribution(string username, uint64 useContribution) public returns (bool) {
        
        if (userExisted(username)) {
            
            //消耗剩余贡献值
            userMap[username].residualContribution -= useContribution;
            
            return true;
            
        }
        
        return false;
    }
    
    //获取用户贡献值情况
    function getContributionStatusWithUser(string username) public constant returns (uint64, uint64) {
        
        return (userMap[username].totalContribution, userMap[username].residualContribution);
        
    }
    
    //获取发布漏洞数
    function getNumberOfReleasedVulnerability(string username) public constant returns (uint64) {
        return userMap[username].vCount;
    }
    
    //根据索引获取发布漏洞的ipfs哈希（用于后端遍历）
    function getVulnerabilityIpfsHashByIndex(string username, uint64 index) public constant returns (string) {
        return userMap[username].vulnerabilities[index];
    }
    
    //获取发布补丁数
    function getNumberOfReleasedPatch(string username) public constant returns (uint64) {
        return userMap[username].pCount;
    }
    
    //根据索引获取发布补丁的ipfs哈希（用户后端遍历）
    function getPatchIpfsHashByIndex(string username, uint64 index) public constant returns (string) {
        return userMap[username].patches[index];
    }
    
    //根据用户名获取对应的漏洞评分
    function getVulnerabilityAssessScoreByUser(string username, string assessor) public constant returns (uint8) {
        return userMap[username].vulnerabilitiesScore[assessor];
    }
    
    //根据用户名获取对应的补丁评分
    function getPatchAssessScoreByUser(string username, string assessor) public constant returns (uint8) {
        return userMap[username].patchesScore[assessor];
    }
    
    
}    